<h1>Oscilloscope Graphics</h1>
<h2>Project Overview</h2>
<p>
    It has been a common trick for a long time to use an analog oscilloscope to draw shapes and patterns to its display. This works by applying two voltages to channels 1 and 2 of the scope to control the horizontal and vertical position of the oscilloscopes electron beam. When the beam is moved quickly from one place to another, it leaves behind a bright glowing trail of green light which quickly disappears.
</p>
<p>
    The idea came to mind that I could use the digital to analog converters (DAC) of a micro-controller to generate two voltages which could be used to control the position of the beam on the scope. I used an ESP32 devlopment board which has two 10-bit DACs built in. This provides 2^10 or 1024 different voltages between 0V and 3.3V for both X and Y.
</p>
<h2>First Program!</h2>
<p>
    After connecting the micro to the scope, the only thing left to do is write some code! The first program which I wrote was a basic 2D particle in a box physics simulation. The particle was given a mass and initial velocity, and with collision handling and gravity was implimented, a rather convincing "bouncing ball in a box" simulation was created.
</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/lEnchWlrA0M?si=DdLEtIfPl3doS2ac" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="width: 70%; height: 350px; margin: 0 auto; display: block;"></iframe>

<h2>Going Further</h2>
<p>
    While the particle simulation was a cool project in of its self, I wanted to go further. I wanted to draw lines and shapes. The first thing I wanted do was draw a basic square. 
    
    I first tried to do this by quickely switching the beam position between the four corners of a square. My thinking being that the edges of the square would be drawn as beam travels between the corners. It turns out that the beam of the oscilloscope can move incredibly quickly, and that instead of drawing edges, it just jumps between the corners leaving four point souces of light.
    
    What I realised I needed to do was move the beam position in small increments between the four corners. That way, the beam would draw many point sources close together in a line. And if they were close enough, you shouldn't be able to tell that it is not a continuous line being drawn.

    Below is a slow motion video of some basic shapes being drawn using this method.
</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/ZSrDUwyOw7A" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="width: 70%; height: 350px; margin: 0 auto; display: block;"></iframe>

<h2>General Purpose Graphics Library</h2>

<p>
    At this point in the project, I was getting quite excited about the possibilities. I was very impressed by how well the drawn lines looked. The problem was that drawing anything to the display required hard coding the position and timing of the beam.
</p>

<p>
    I decided that I should write a general purpose graphics library. This library would provide provide general-purpose functions draw a large variety of different shapes. For example the void draw_center_rectangle(int32_t width, int32_t height, int32_t xpos, int32_t ypos). Allows the user to draw a rectangle easily given several basic paramaters which describe the size and shape.

    There are two functions which are called to control the drawing graphics_update() and clear_screen() which both do what they say.
</p>

<p>
    There are several limitations with this whole setup. The driver currently only supports drawing shapes with straight edges; however, this may be improved in the future to support things like Bezzier curves etc. The other limitation is how quickly the DACs can update. This translates to a limitation in the number of lines and shapes on the screen. Too many, and the frame rate drops enough for it to be vissible.
</p>

<h2>
    Pong On An Oscilloscope!
</h2>
<p>
    Obviously, it would have been a waste to write a graphics library from scratch and then not use it for it as the basis for a game. I've done a decent ammount of programming, but I've never programmed a game before. Even though pong is a very simple game, there is lots to learn from drawing the scene, managing game states, updating points, managing object collision detection and physics.
</p>

<p>
    Here is a look at the finished game in action!
</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/TT7ZzPn_dco" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="width: 70%; height: 350px; margin: 0 auto; display: block;"></iframe>

<p>
    And because I think it's really cool... Here is a video of the pong game being rendered on the oscilloscope in slow motion!
</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/zBnkp1maNaQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="width: 70%; height: 350px; margin: 0 auto; display: block;"></iframe>